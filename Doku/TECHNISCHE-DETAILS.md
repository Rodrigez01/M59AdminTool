# Technische Details: QuestEditor Implementation

**Erstellt am:** 2026-01-04
**Zweck:** Detaillierte technische Informationen für Entwickler und KI-Assistenten

---

## Inhaltsverzeichnis

1. [KodFileService Details](#kodfileservice-details)
2. [Kod-Parsing](#kod-parsing)
3. [Code-Generierung](#code-generierung)
4. [Bekannte Limitierungen](#bekannte-limitierungen)
5. [Debugging-Tipps](#debugging-tipps)
6. [Beispiel-Quests](#beispiel-quests)

---

## KodFileService Details

### Pfad-Auflösung

```csharp
private string ResolveQuestTemplatePath(string? serverRootPath)
{
    var candidates = new List<string>();

    // 1) Parameter-basiert
    if (!string.IsNullOrWhiteSpace(serverRootPath))
        candidates.Add(Path.Combine(serverRootPath, "kod", "object", "passive", "questtemplate"));

    // 2) Config-basiert (QuestEditor.ini)
    var configService = new ConfigService();
    var config = configService.LoadConfig();
    if (configService.IsConfigValid(config))
    {
        candidates.Add(Path.Combine(config.KodPath, "object", "passive", "questtemplate"));
    }

    // Bevorzugt: Pfad mit .kod-Dateien
    foreach (var path in candidates)
    {
        if (Directory.Exists(path) && Directory.GetFiles(path, "*.kod").Any())
            return path;
    }

    // Fallback: erster existierender Pfad
    foreach (var path in candidates)
    {
        if (Directory.Exists(path))
            return path;
    }

    throw new DirectoryNotFoundException("Questtemplate-Pfad nicht gefunden");
}
```

### Quest-Validierung

```csharp
private void ValidateAndFixQuestStructure(Quest quest)
{
    // QuestKodClass darf keine Pfad-Zeichen enthalten
    if (quest.QuestKodClass.Contains("\\") ||
        quest.QuestKodClass.Contains("/") ||
        quest.QuestKodClass.Contains(":"))
    {
        throw new ArgumentException("QuestKodClass darf keine Pfad-Zeichen enthalten");
    }

    // Node-Indizes müssen sequenziell sein
    for (int i = 0; i < quest.Nodes.Count; i++)
    {
        quest.Nodes[i].NodeIndex = i;
    }

    // Dialoge validieren
    foreach (var node in quest.Nodes)
    {
        if (node.Dialogs == null)
            node.Dialogs = new List<Dialog>();
    }
}
```

### .kod-Datei Generierung

**Struktur:**

```csharp
private string GenerateKodFile(Quest quest, bool hasNonEnDialogs)
{
    var sb = new StringBuilder();

    // Header
    sb.AppendLine($"// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.");
    sb.AppendLine($"// Quest generated by QuestEditor v2.12");
    sb.AppendLine();

    // Class declaration
    sb.AppendLine($"{quest.QuestKodClass} is QuestTemplate");
    sb.AppendLine($"// Quest template QST_ID_{quest.QuestKodClass.ToUpper()} = {quest.QuestTemplateId}");
    sb.AppendLine();

    // Constants block
    sb.AppendLine("constants:");
    sb.AppendLine();
    sb.AppendLine("   include blakston.khd");
    sb.AppendLine();

    // Resources block
    sb.AppendLine("resources:");
    sb.AppendLine();
    if (hasNonEnDialogs)
        sb.AppendLine($"   include {quest.QuestKodClass.ToLower()}.lkod");
    sb.AppendLine();

    // Resource definitions
    sb.AppendLine($"   {quest.QuestKodClass.ToLower()}_icon_rsc = {quest.IconFilename ?? "default.bgf"}");
    sb.AppendLine($"   {quest.QuestKodClass.ToLower()}_name_rsc = \"{quest.QuestName}\"");
    sb.AppendLine($"   {quest.QuestKodClass.ToLower()}_desc_rsc = \\");
    sb.AppendLine($"      \"{quest.QuestDescription}\"");
    sb.AppendLine();

    // Node descriptions
    foreach (var node in quest.Nodes.Skip(1)) // Skip first node
    {
        var nodeResName = $"{quest.QuestKodClass.ToLower()}_node{node.NodeIndex}_rsc";
        sb.AppendLine($"   {nodeResName} = \\");
        sb.AppendLine($"      \"Node {node.NodeIndex} description\"");
        sb.AppendLine();
    }

    // Classvars block
    sb.AppendLine("classvars:");
    sb.AppendLine();
    sb.AppendLine("   vrIcon = " + quest.QuestKodClass.ToLower() + "_icon_rsc");
    sb.AppendLine("   vrName = " + quest.QuestKodClass.ToLower() + "_name_rsc");
    sb.AppendLine("   vrDesc = " + quest.QuestKodClass.ToLower() + "_desc_rsc");
    sb.AppendLine();
    sb.AppendLine($"   viQuestID = QST_ID_{quest.QuestKodClass.ToUpper()}");
    sb.AppendLine();

    // Properties block
    sb.AppendLine("properties:");
    sb.AppendLine();
    sb.AppendLine($"   piNumPlayers = {quest.NumPlayers}");
    sb.AppendLine($"   piMaxPlayers = {quest.MaxActivePlayers}");
    sb.AppendLine($"   piSchedulePct = {quest.SchedulePercent}");

    if (quest.PlayerRestrictions != null && quest.PlayerRestrictions.Any())
    {
        var restrictions = string.Join(" | ", quest.PlayerRestrictions);
        sb.AppendLine($"   piPlayerRestrict = {restrictions}");
    }
    sb.AppendLine();

    // Messages block
    GenerateMessagesBlock(sb, quest);

    sb.AppendLine("end");
    sb.AppendLine("////////////////////////////////////////////////////////////////////////////////");

    return sb.ToString();
}
```

### Messages Block Generierung

```csharp
private void GenerateMessagesBlock(StringBuilder sb, Quest quest)
{
    sb.AppendLine("messages:");
    sb.AppendLine();

    // Constructor
    sb.AppendLine("   Constructor()");
    sb.AppendLine("   {");
    sb.Append("      plQuestNodes = [");

    var nodeIds = quest.Nodes.Select((n, i) =>
        $"QNT_ID_{quest.QuestKodClass.ToUpper()}_{NumberToWord(i + 1).ToUpper()}");
    sb.Append(string.Join(", ", nodeIds));

    sb.AppendLine("];");
    sb.AppendLine();
    sb.AppendLine("      propagate;");
    sb.AppendLine("   }");
    sb.AppendLine();

    // SendQuestNodeTemplates
    sb.AppendLine("   SendQuestNodeTemplates()");
    sb.AppendLine("   {");
    sb.AppendLine("      local lNPCs, oQE, oLib, oNPC;");
    sb.AppendLine();
    sb.AppendLine("      oQE = Send(SYS, @GetQuestEngine);");
    sb.AppendLine("      oLib = Send(SYS, @GetLibrary);");
    sb.AppendLine();

    // Generate each node
    for (int i = 0; i < quest.Nodes.Count; i++)
    {
        GenerateQuestNode(sb, quest, quest.Nodes[i], i);
    }

    sb.AppendLine("      return;");
    sb.AppendLine("   }");
    sb.AppendLine();
}

private string NumberToWord(int num)
{
    string[] words = { "ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE",
                       "SIX", "SEVEN", "EIGHT", "NINE", "TEN" };
    return num < words.Length ? words[num] : num.ToString();
}
```

### Quest-Node Generierung

```csharp
private void GenerateQuestNode(StringBuilder sb, Quest quest, QuestNode node, int index)
{
    var nodeId = $"QNT_ID_{quest.QuestKodClass.ToUpper()}_{NumberToWord(index + 1).ToUpper()}";

    sb.AppendLine($"      // Template #{node.NodeIndex} - {node.NodeType}");
    sb.AppendLine($"      if Send(oQE, @AddQuestNodeTemplate,");
    sb.AppendLine($"              #questnode_type={node.NodeType},");

    // NPC Modifier
    if (!string.IsNullOrEmpty(node.NpcModifier))
        sb.AppendLine($"              #NPC_modifier={node.NpcModifier},");

    // Cargo List
    if (node.CargoList != null && node.CargoList.Any())
    {
        sb.Append("              #cargolist=[");
        GenerateCargoList(sb, node.CargoList);
        sb.AppendLine("],");
    }

    // Prize List
    if (node.PrizeList != null && node.PrizeList.Any())
    {
        sb.Append("              #prizelist=[");
        GeneratePrizeList(sb, node.PrizeList);
        sb.AppendLine("],");
    }

    // Time Limit
    if (node.TimeLimit > 0)
        sb.AppendLine($"              #timelimit={node.TimeLimit},");

    sb.AppendLine($"              #quest_node_index={nodeId})");
    sb.AppendLine("      {");

    // NPC List Setup
    if (node.NpcClasses != null && node.NpcClasses.Any())
    {
        sb.AppendLine("         lNPCs = $;");
        foreach (var npcClass in node.NpcClasses)
        {
            sb.AppendLine($"         foreach oNPC in Send(oLib, @GetOccupationList, #cNPC_class={npcClass})");
            sb.AppendLine("         {");
            sb.AppendLine("            lNPCs = Cons(oNPC, lNPCs);");
            sb.AppendLine("         }");
        }
        sb.AppendLine($"         Send(oQE, @SetQuestNodeNPCList,");
        sb.AppendLine($"              #index={nodeId},");
        sb.AppendLine($"              #new_NPC_list=lNPCs);");
    }

    // Dialog Hints
    GenerateDialogHints(sb, node, nodeId);

    sb.AppendLine("      }");
    sb.AppendLine("      else");
    sb.AppendLine("      {");
    sb.AppendLine($"         Debug(\"Error building QN: {nodeId}\");");
    sb.AppendLine("      }");
    sb.AppendLine();
}
```

---

## Kod-Parsing

### Regex-Patterns

**Class Name:**
```csharp
var classNameRegex = new Regex(@"^(\w+)\s+is\s+(\w+)", RegexOptions.Multiline);
var match = classNameRegex.Match(kodContent);
var className = match.Groups[1].Value;
var superClass = match.Groups[2].Value;
```

**Resources:**
```csharp
var resourceRegex = new Regex(
    @"(\w+)\s*=\s*""([^""]+)""",
    RegexOptions.Multiline);

foreach (Match match in resourceRegex.Matches(kodContent))
{
    var resName = match.Groups[1].Value;
    var resValue = match.Groups[2].Value;
}
```

**Multi-line Resources:**
```csharp
var multilineResRegex = new Regex(
    @"(\w+)\s*=\s*\\\s*\n\s*""([^""]+)""",
    RegexOptions.Multiline);
```

**Quest Node IDs:**
```csharp
var nodeIdRegex = new Regex(
    @"plQuestNodes\s*=\s*\[([\w\s,]+)\]",
    RegexOptions.Multiline);

var match = nodeIdRegex.Match(kodContent);
var nodeIds = match.Groups[1].Value
    .Split(',')
    .Select(s => s.Trim())
    .ToList();
```

**Node Type:**
```csharp
var nodeTypeRegex = new Regex(
    @"#questnode_type\s*=\s*(\w+)",
    RegexOptions.Multiline);
```

**NPC Classes:**
```csharp
var npcClassRegex = new Regex(
    @"#cNPC_class\s*=\s*(&\w+)",
    RegexOptions.Multiline);
```

**Cargo List:**
```csharp
var cargoRegex = new Regex(
    @"#cargolist\s*=\s*\[(.*?)\]",
    RegexOptions.Singleline);

// Parse: [ [ QN_PRIZETYPE_ITEMCLASS, &Item, 5 ] ]
var cargoItems = ParseNestedList(cargoMatch.Groups[1].Value);
```

---

## Code-Generierung

### .lkod-Datei (Übersetzungen)

```csharp
private string GenerateLkodFile(Quest quest)
{
    var sb = new StringBuilder();

    sb.AppendLine($"// {quest.QuestKodClass} Localization File");
    sb.AppendLine($"// Generated by QuestEditor v2.12");
    sb.AppendLine();

    foreach (var node in quest.Nodes)
    {
        if (node.Dialogs == null) continue;

        foreach (var dialog in node.Dialogs)
        {
            if (string.IsNullOrWhiteSpace(dialog.DialogContext) ||
                dialog.DialogContext.ToLower() == "en")
                continue;

            var resName = $"{quest.QuestKodClass.ToLower()}_" +
                         $"node{node.NodeIndex}_{dialog.DialogType}";

            sb.AppendLine($"{resName} = {dialog.DialogContext} \"{dialog.DialogText}\"");
        }
    }

    return sb.ToString();
}
```

**Beispiel-Output:**
```
apothecaryqt_node2_assign = de "Bitte liefere diese Items zu %NPC."
apothecaryqt_node2_success = de "Vielen Dank für die Lieferung!"
```

### Makefile-Integration

```csharp
private bool TryAddBofToMakefileLines(List<string> lines, string bofFileName, out List<string> newLines)
{
    newLines = new List<string>(lines);

    // Finde BOFS = Zeile
    int bofsIndex = -1;
    for (int i = 0; i < newLines.Count; i++)
    {
        if (newLines[i].Trim().StartsWith("BOFS"))
        {
            bofsIndex = i;
            break;
        }
    }

    if (bofsIndex == -1)
        return false;

    // Finde letzte .bof-Zeile
    int lastBofIndex = bofsIndex;
    for (int i = bofsIndex + 1; i < newLines.Count; i++)
    {
        if (newLines[i].Contains(".bof"))
            lastBofIndex = i;
        else if (!newLines[i].Trim().StartsWith("#") &&
                 !string.IsNullOrWhiteSpace(newLines[i]))
            break;
    }

    // Entferne Backslash von letzter Zeile
    var lastLine = newLines[lastBofIndex].TrimEnd();
    if (lastLine.EndsWith("\\"))
        lastLine = lastLine.Substring(0, lastLine.Length - 1).TrimEnd();
    newLines[lastBofIndex] = lastLine;

    // Füge neue .bof-Zeile hinzu
    newLines.Insert(lastBofIndex + 1, $"    {bofFileName} \\");

    return true;
}
```

---

## Bekannte Limitierungen

### 1. Integer-Overflow

**Problem:** Blakod unterstützt nur 27-Bit-Integers (-134,217,728 bis 134,217,727)

**Beispiel:**
```kod
// FEHLER: Überlauf!
iValue = 200000000;

// RICHTIG: Innerhalb des Bereichs
iValue = 100000000;
```

**Lösung im Editor:**
- Validierung bei Zahlen-Eingaben
- Warnung bei großen Werten

### 2. Nil-Handling

**Problem:** `$` kann nicht in Ausdrücken verwendet werden

```kod
// FEHLER:
iValue = $ + 10;

// RICHTIG:
if oObject = $
{
    // Handle nil
}
```

### 3. String-Encoding

**Problem:** Blakod-Compiler erwartet UTF-8 ohne BOM

**Editor-Lösung:**
```csharp
await File.WriteAllTextAsync(filePath, content, new UTF8Encoding(false));
```

### 4. Resource-Namen

**Problem:** Resource-Namen müssen eindeutig sein innerhalb einer .kod-Datei

**Konvention:**
```kod
// RICHTIG:
questname_trigger_rsc = "help"
questname_assign_rsc = "Please help me!"

// FALSCH (Konflikt):
trigger_rsc = "help"
trigger_rsc = "assist"
```

### 5. NPC-Klassen

**Problem:** NPC-Klassennamen müssen exakt mit dem Code übereinstimmen

**Beispiele:**
```kod
// RICHTIG:
&BarloqueTown
&TosTown
&JasperInnKeeper

// FALSCH:
&Barloque_Town  // Unterstrich statt CamelCase
&barloquetown   // Kleinschreibung
```

---

## Debugging-Tipps

### 1. .kod-Syntax prüfen

```bash
# Kompiliere einzelne Datei
cd server/blakserv
bc questtemplate/testquest.kod

# Fehler-Ausgabe zeigt Zeile + Problem
```

### 2. Quest-Node-IDs prüfen

```bash
# Suche nach QNT_ID Definitionen
grep "QNT_ID_TESTQUEST" include/blakston.khd

# Sollte zeigen:
# #define QNT_ID_TESTQUEST_ONE 200
# #define QNT_ID_TESTQUEST_TWO 201
```

### 3. Makefile-Eintrag prüfen

```bash
# Prüfe, ob .bof in Liste
grep "testquest.bof" kod/object/passive/questtemplate/makefile
```

### 4. .lkod-Syntax prüfen

**.lkod-Dateien** müssen folgendes Format haben:
```
resource_name = language "text"
```

**Häufige Fehler:**
```
// FALSCH: Fehlendes Language-Tag
resource_name = "text"

// RICHTIG:
resource_name = de "text"
```

### 5. Server-Log prüfen

```bash
# Server im Debug-Mode starten
./blakserv -debug

# Quest-Engine-Fehler im Log suchen
tail -f blakserv.log | grep "Quest"
```

### 6. Quest-Engine-Status

**Im Spiel (als Admin):**
```
/show quest QST_ID_TESTQUEST
/show questnode QNT_ID_TESTQUEST_ONE
```

---

## Beispiel-Quests

### Minimal-Quest (1 Node)

```kod
MinimalQuest is QuestTemplate

constants:
   include blakston.khd

resources:
   minimalquest_icon_rsc = default.bgf
   minimalquest_name_rsc = "Minimal Quest"
   minimalquest_desc_rsc = "Just show up at NPC"

classvars:
   vrIcon = minimalquest_icon_rsc
   vrName = minimalquest_name_rsc
   vrDesc = minimalquest_desc_rsc
   viQuestID = QST_ID_MINIMAL

properties:
   piNumPlayers = 1
   piMaxPlayers = 10
   piSchedulePct = 100

messages:
   Constructor()
   {
      plQuestNodes = [QNT_ID_MINIMAL_ONE];
      propagate;
   }

   SendQuestNodeTemplates()
   {
      local lNPCs, oQE, oLib, oNPC;

      oQE = Send(SYS, @GetQuestEngine);
      oLib = Send(SYS, @GetLibrary);

      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_SHOWUP,
              #quest_node_index=QNT_ID_MINIMAL_ONE)
      {
         lNPCs = $;
         foreach oNPC in Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown)
         {
            lNPCs = Cons(oNPC, lNPCs);
         }
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_MINIMAL_ONE,
              #new_NPC_list=lNPCs);
      }

      return;
   }

end
```

### Dialog-Quest (2 Nodes)

```kod
DialogQuest is QuestTemplate

constants:
   include blakston.khd

resources:
   dialogquest_icon_rsc = scroll.bgf
   dialogquest_name_rsc = "Dialog Quest"
   dialogquest_desc_rsc = "Say the magic word"

   dialogquest_trigger = "help"
   dialogquest_assign = "Say 'help' to me if you need assistance."
   dialogquest_success = "Here is your reward!"

classvars:
   vrIcon = dialogquest_icon_rsc
   vrName = dialogquest_name_rsc
   vrDesc = dialogquest_desc_rsc
   viQuestID = QST_ID_DIALOG

properties:
   piNumPlayers = 1

messages:
   Constructor()
   {
      plQuestNodes = [QNT_ID_DIALOG_ONE, QNT_ID_DIALOG_TWO];
      propagate;
   }

   SendQuestNodeTemplates()
   {
      local oQE, oLib;

      oQE = Send(SYS, @GetQuestEngine);
      oLib = Send(SYS, @GetLibrary);

      // Node 1: Show up
      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_SHOWUP,
              #quest_node_index=QNT_ID_DIALOG_ONE)
      {
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_DIALOG_ONE,
              #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));
      }

      // Node 2: Say trigger word
      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_MESSAGE,
              #cargolist=[dialogquest_trigger],
              #prizelist=[ [ [QN_PRIZETYPE_ITEMCLASS, &Shillings, 100] ] ],
              #quest_node_index=QNT_ID_DIALOG_TWO)
      {
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_DIALOG_TWO,
              #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));
         Send(oQE, @SetQuestNodeAssignHint,
              #index=QNT_ID_DIALOG_TWO,
              #new_hint=dialogquest_assign);
         Send(oQE, @SetQuestNodeSuccessHint,
              #index=QNT_ID_DIALOG_TWO,
              #new_hint=dialogquest_success);
      }

      return;
   }

end
```

### Item-Delivery-Quest (3 Nodes)

```kod
DeliveryQuest is QuestTemplate

constants:
   include blakston.khd

resources:
   deliveryquest_icon_rsc = package.bgf
   deliveryquest_name_rsc = "Delivery Quest"
   deliveryquest_desc_rsc = "Deliver items to NPC"

   deliveryquest_assign = "Take these %CARGO to %NPC."
   deliveryquest_success = "Thank you for the delivery!"
   deliveryquest_failure = "You lost the items!"

classvars:
   vrIcon = deliveryquest_icon_rsc
   vrName = deliveryquest_name_rsc
   vrDesc = deliveryquest_desc_rsc
   viQuestID = QST_ID_DELIVERY

properties:
   piNumPlayers = 1

messages:
   Constructor()
   {
      plQuestNodes = [QNT_ID_DELIVERY_ONE, QNT_ID_DELIVERY_TWO, QNT_ID_DELIVERY_THREE];
      propagate;
   }

   SendQuestNodeTemplates()
   {
      local lNPCs, oQE, oLib;

      oQE = Send(SYS, @GetQuestEngine);
      oLib = Send(SYS, @GetLibrary);

      // Node 1: Show up at quest giver
      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_SHOWUP,
              #quest_node_index=QNT_ID_DELIVERY_ONE)
      {
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_DELIVERY_ONE,
              #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));
      }

      // Node 2: Receive items
      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_ITEM,
              #NPC_modifier=QN_NPCMOD_NONE,
              #cargolist=[ [ QN_PRIZETYPE_ITEMCLASS, &Apple, 5 ] ],
              #quest_node_index=QNT_ID_DELIVERY_TWO)
      {
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_DELIVERY_TWO,
              #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));
         Send(oQE, @SetQuestNodeAssignHint,
              #index=QNT_ID_DELIVERY_TWO,
              #new_hint=deliveryquest_assign);
      }

      // Node 3: Deliver items to different NPC
      if Send(oQE, @AddQuestNodeTemplate,
              #questnode_type=QN_TYPE_ITEM,
              #NPC_modifier=QN_NPCMOD_DIFFERENT,
              #cargolist=[ [ QN_PRIZETYPE_ITEMCLASS, &Apple, 5 ] ],
              #prizelist=[ [ [QN_PRIZETYPE_ITEMCLASS, &Shillings, 500] ] ],
              #penaltylist=[ [ QN_PRIZETYPE_OUTLAW ] ],
              #timelimit=3600,
              #quest_node_index=QNT_ID_DELIVERY_THREE)
      {
         Send(oQE, @SetQuestNodeNPCList,
              #index=QNT_ID_DELIVERY_THREE,
              #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&TosTown));
         Send(oQE, @SetQuestNodeSuccessHint,
              #index=QNT_ID_DELIVERY_THREE,
              #new_hint=deliveryquest_success);
         Send(oQE, @SetQuestNodeFailureHint,
              #index=QNT_ID_DELIVERY_THREE,
              #new_hint=deliveryquest_failure);
      }

      return;
   }

end
```

---

## Spezial-Platzhalter in Dialog-Texten

### Verfügbare Platzhalter

| Platzhalter | Bedeutung | Beispiel |
|-------------|-----------|----------|
| `%NPC` | Name des Ziel-NPCs | "Barloque Elder" |
| `%SOURCE_NPC` | Name des Quest-Gebers | "Jasper Innkeeper" |
| `%HIMHER_NPC` | him/her für NPC | "him", "her" |
| `%HISHER_NPC` | his/her für NPC | "his", "her" |
| `%CARGO` | Name des Cargo-Items | "Apples" |
| `%INDEF_CARGO` | Artikel + Cargo | "some apples" |
| `%PRIZE` | Name der Belohnung | "Long Sword" |
| `%NAME` | Name des Spielers | wird ersetzt |
| `%NUM` | Anzahl der Items | "5" |

### Verwendung

```kod
deliveryquest_assign =
   "%SOURCE_NPC has asked you to deliver %NUM %CARGO to %NPC. "
   "Please give them to %HIMHER_NPC within one hour."

// Wird zu:
// "Jasper Innkeeper has asked you to deliver 5 apples to Barloque Elder.
//  Please give them to him within one hour."
```

---

## Performance-Tipps

### 1. NPC-Listen cachen

```kod
// SCHLECHT: Mehrfach abfragen
Send(oQE, @SetQuestNodeNPCList,
     #index=QNT_ID_ONE,
     #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));
Send(oQE, @SetQuestNodeNPCList,
     #index=QNT_ID_TWO,
     #new_NPC_list=Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown));

// GUT: Einmal abfragen
lNPCs = Send(oLib, @GetOccupationList, #cNPC_class=&BarloqueTown);
Send(oQE, @SetQuestNodeNPCList, #index=QNT_ID_ONE, #new_NPC_list=lNPCs);
Send(oQE, @SetQuestNodeNPCList, #index=QNT_ID_TWO, #new_NPC_list=lNPCs);
```

### 2. Listen-Operationen

```kod
// SCHLECHT: O(n) für jedes Element
lItems = [];
foreach oItem in lSource
{
   lItems = lItems @ [oItem];  // Append ist langsam!
}

// GUT: O(1) für jedes Element
lItems = $;
foreach oItem in lSource
{
   lItems = Cons(oItem, lItems);  // Prepend ist schnell
}
```

### 3. Integer-Berechnungen

```kod
// Division durch 2: Langsam
iHalf = iValue / 2;

// Bit-Shift: Schneller (nur für Potenzen von 2)
// ACHTUNG: In Blakod nicht verfügbar, nur in C-Calls
```

---

**Ende der Technischen Details**

Weitere Informationen: Siehe `doc/kodccalls.md` für vollständige C-Call-Referenz.
